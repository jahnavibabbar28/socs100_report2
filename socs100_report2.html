<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.57">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>socs0100_report2</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="socs100_report2_files/libs/clipboard/clipboard.min.js"></script>
<script src="socs100_report2_files/libs/quarto-html/quarto.js"></script>
<script src="socs100_report2_files/libs/quarto-html/popper.min.js"></script>
<script src="socs100_report2_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="socs100_report2_files/libs/quarto-html/anchor.min.js"></script>
<link href="socs100_report2_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="socs100_report2_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="socs100_report2_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="socs100_report2_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="socs100_report2_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">


</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">socs0100_report2</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="health-insurance-coverage-in-the-united-states" class="level1">
<h1>Health Insurance Coverage in the United States</h1>
<section id="report-word-count-1521" class="level4">
<h4 class="anchored" data-anchor-id="report-word-count-1521">Report Word Count: 1521</h4>
</section>
<section id="introduction" class="level2">
<h2 class="anchored" data-anchor-id="introduction">Introduction</h2>
<p>In recent years, expanding universal health insurance coverage has been the primary health policy in healthcare reform around the world, including in developed and developing countries, such as the USA, Mexico, and China (Wang <em>et al</em>., <a href="https://onlinelibrary.wiley.com/doi/full/10.1002/hec.3225?casa_token=waH70xV5AHkAAAAA%3A_MztfQt-x4pBH-IpdIfjIIYvhYSuci61p8Y_devM56aGS-KLPPMUbdt_N_YL4vNRAmAPN0EHlPqMicn7#hec3225-bib-0031">2012</a>). These efforts aim to address disparities in access to healthcare, reduce out-of-pocket expenses, and improve population health outcomes. Nonetheless, many spatial dependencies and demographic inequalities in the health insurance realm still persist.</p>
<p>This report aims to examine health insurance trends in the United States, particularly analysing 2019 US Census data. By scraping and visualising health insurance data from the American Community Survey (ACS), this report aims to investigate spatial trends in US health insurance using publicly available data. This data set provided valuable and extensive data on the health insurance system in the US, such as health insurance types by age and state – making this valuable information for data-driven work in the social sciences and policy-making.</p>
</section>
<section id="part-i-a-automated-data-collection" class="level2">
<h2 class="anchored" data-anchor-id="part-i-a-automated-data-collection">Part I-A Automated Data Collection</h2>
<p>In this report, the primary dataset utilized for analyzing US healthcare insurance coverage trends was sourced from the American Community Survey (ACS) 2019, under the US Census Bureau. The ACS provides granular, state-level data on various social and economic indicators, including healthcare insurance coverage.</p>
<p><strong>Scraping the Data</strong></p>
<p>For this project, the data was accessed using an API wrapped, via the <code>tidycensus</code> package in R, which allows users to interact with the Census Bureau’s API and automate the collection of large-scale real-world data. The ACS provides estimates of health insurance coverage for both individuals and households, including those who are uninsured, privately insured, and publicly insured.</p>
<p>To access the census data, an API key must be requested from the user from the <a href="https://api.census.gov/data/key_signup.html">US Government’s Census Portal</a>. After saving this API key, it must be set as an environment variable, as seen below, to be able to access the data.</p>
<p>The use of an API allows for large datasets to be gathered and updated efficiently, providing a comprehensive overview for studying trends such as health insurance.</p>
<p>Following this, to scrape data from the ACS, the <code>get_acs</code> function was used to obtain data by variable, for a given geography and obtain relevant Shapefiles, as this project employs a mapping visual as well. The Shapefiles were accessed through the census using a geometry = TRUE argument, in the API call. This should send an API call for the following:</p>
<div class="cell">
<div class="cell-output cell-output-stderr">
<pre><code>Getting data from the 2015-2019 5-year ACS</code></pre>
</div>
<div class="cell-output cell-output-stderr">
<pre><code>Downloading feature geometry from the Census website.  To cache shapefiles for use in future sessions, set `options(tigris_use_cache = TRUE)`.</code></pre>
</div>
</div>
</section>
<section id="part-i-b-data-exploration-and-contextualization" class="level2">
<h2 class="anchored" data-anchor-id="part-i-b-data-exploration-and-contextualization">Part I-B Data Exploration and Contextualization</h2>
<p><strong>Filtering Data</strong></p>
<p>Filtering the dataset included selecting the relevant variables and ensuring data entries were all named properly, ensure dataset clarity. This also included the creation of variables such as % variables.</p>
<p>For instance, these data tidying steps are seen below for the data needed for the first visualisation,</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>state_insurance <span class="ot">&lt;-</span> state_insurance <span class="sc">%&gt;%</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">rename</span>(</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>    <span class="at">state =</span> NAME,</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>    <span class="at">total_population =</span> B27010_001E,</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>    <span class="at">uninsured =</span> B27010_002E,</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>    <span class="at">privately_insured =</span> B27010_003E,</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>    <span class="at">publicly_insured =</span> B27010_004E</span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>  ) <span class="sc">%&gt;%</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>  <span class="fu">mutate</span>(</span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>    <span class="at">uninsured_rate =</span> uninsured <span class="sc">/</span> total_population <span class="sc">*</span> <span class="dv">100</span>,</span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>    <span class="at">private_insurance_rate =</span> privately_insured <span class="sc">/</span> total_population <span class="sc">*</span> <span class="dv">100</span>,</span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>    <span class="at">public_insurance_rate =</span> publicly_insured <span class="sc">/</span> total_population <span class="sc">*</span> <span class="dv">100</span></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>  )</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Another key aspect of the data wrangling process was working with age data and health insurance type data. As seen below, the pivot_longer function was used to facilitate the separation and creation of a new variable.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="co">#| warning: false</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>age_insurance <span class="ot">&lt;-</span> age_insurance <span class="sc">%&gt;%</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">pivot_longer</span>(</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>    <span class="at">cols =</span> <span class="fu">starts_with</span>(<span class="st">"private_"</span>) <span class="sc">|</span> <span class="fu">starts_with</span>(<span class="st">"public_"</span>) <span class="sc">|</span> <span class="fu">starts_with</span>(<span class="st">"uninsured_"</span>),</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>    <span class="at">names_to =</span> <span class="fu">c</span>(<span class="st">"insurance_type"</span>, <span class="st">"age_group"</span>),</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>    <span class="at">names_sep =</span> <span class="st">"_"</span>,</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>    <span class="at">values_to =</span> <span class="st">"population"</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>  )</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stderr">
<pre><code>Warning: Expected 2 pieces. Additional pieces discarded in 9 rows [1, 2, 3, 4, 5, 6, 7,
8, 9].</code></pre>
</div>
</div>
<p>Similarly, the data for all three visualisations which are to be present on the interactive dashboard, were tidied and wrangled from the raw US Census format. The table below shows a list of the variables extracted.</p>
<table class="caption-top table">
<colgroup>
<col style="width: 30%">
<col style="width: 69%">
</colgroup>
<thead>
<tr class="header">
<th>Variable</th>
<th>Variable Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Uninsured</td>
<td>Number of uninsured individuals in each state.</td>
</tr>
<tr class="even">
<td>Privately Insured</td>
<td>Number of privately insured individuals in each state.</td>
</tr>
<tr class="odd">
<td>Publicly Insured</td>
<td>Number of publicly insured individuals in each state.</td>
</tr>
<tr class="even">
<td>State</td>
<td>US State</td>
</tr>
<tr class="odd">
<td>Uninsured Rate</td>
<td>% of uninsured individuals in each state.</td>
</tr>
<tr class="even">
<td>Privately Insured Rate</td>
<td>% of privately insured individuals in each state.</td>
</tr>
<tr class="odd">
<td>Publicly Insured Rate</td>
<td>% of publicly insured individuals in each state.</td>
</tr>
<tr class="even">
<td>Age Group</td>
<td>Age group: under 18, 18-64 and 65+.</td>
</tr>
<tr class="odd">
<td>Year</td>
<td>Year in which data was collected.</td>
</tr>
</tbody>
</table>
<p><strong>Table 1:</strong> Dataset Variables Description Table</p>
</section>
<section id="part-ii-a-building-an-interactive-dashboard-with-r-shiny" class="level2">
<h2 class="anchored" data-anchor-id="part-ii-a-building-an-interactive-dashboard-with-r-shiny">Part II-A Building an Interactive Dashboard with R Shiny</h2>
<p>Data visualization is a powerful tool for communicating complex insights and trends. In this project, an interactive dashboard was built using an R Shiny App to allow users to gain insight into health insurance trends across different US states. The dashboard features three key visualizations: a choropleth map, a line chart, and a stacked bar chart.</p>
<p><strong>Choropleth Map: Insurance Type % Across the US</strong></p>
<p>The first visualisation in the dashboard is a choropleth map, placed under the first tab of the RShiny Web App. As seen in Image 1.1, the map uses a colour gradient to represent the percentage of the population in each state with a certain insurance type in the US as of 2019.</p>
<p><img src="images/Visualisation1.png" class="img-fluid"></p>
<p><strong>Image 1.1</strong> Choropleth Map Visualisation: Insurance across the US</p>
<p>The visualisation works by inputting a specific insurance type, such as Privately Insured, Publicly Insured, or Uninsured, and provides a spatial overview of the discrepancies across the country. For instance, considering the example of <em>uninsured individuals</em>, it can be noted that Utah and Texas have very high rates, of over 25% of individuals being uninsured. These regional differences provide valuable insight from a policy perspective, particularly when considering planning the implementation of targeted intervention. The use of colour, with yellow representing a higher proportion and dark blue representing a lower proportion, allows for clear visualisation of any emerging trends and patterns.</p>
<p>More notably, when considering privately insured individuals, the proportion is much higher in the eastern region of the country. This highlights possible key inequalities associated with healthcare, and is an interesting trend to analyse from an analytical and policy point of view.</p>
<p><strong>Line Chart over Time: Insurance-Type Trends over Time in the US</strong></p>
<p>The line chart visualization offers an interactive way to explore health insurance coverage trends across the United States from 2015 to 2019. Users can select a specific state to observe detailed year-by-year changes in the number of individuals who are uninsured, privately insured, or publicly insured. By illustrating these shifts, the chart provides valuable insights into how coverage patterns evolve over time, reflecting the impacts of policy changes, economic factors, and demographic shifts.</p>
<p><img src="images/Visualisation2.png" class="img-fluid"></p>
<p><strong>Image 1.2</strong> Line Chart: Insurance Coverage Trends in US States</p>
<p>In most states, a notable trend emerges: the uninsured population tends to represent the largest group, followed by those with private insurance and, finally, public insurance. However, these patterns may vary, especially in states that have expanded Medicaid or introduced other health policy initiatives. Over time, the data highlights fluctuations in insurance coverage categories, offering valuable insights for policymakers, researchers, and stakeholders seeking to improve healthcare accessibility and equity.</p>
<p>This visualization underscores the disparities in health insurance coverage across the country and provides a critical tool for understanding how states adapt to evolving healthcare needs and challenges.</p>
<p><strong>Stacked Bar Chart: Insurance Coverage by Age Group</strong></p>
<p>The third visualization in the RShiny App dashboard illustrates insurance coverage by age group across different US states in 2019. This stacked bar chart provides a detailed breakdown of how individuals in three key age brackets—under 18, economically active adults aged 18 to 64, and those aged 65 and older—are distributed across uninsured, privately insured, and publicly insured categories. By presenting the data in this structured format, the chart enables users to explore disparities in insurance coverage by age group and region, offering a valuable tool for identifying areas in need of targeted interventions.</p>
<p><img src="images/Visualisation3.png" class="img-fluid"></p>
<p><strong>Image 1.3</strong> Stacked Bar Chart showing Insurance Type by Age Group</p>
<p>As seen in Image 1.3, the data reveals that younger individuals, particularly those under 18, make up a significant proportion of the uninsured population. Conversely, public insurance programs, such as Medicare, cover the majority of individuals aged 65 and older, while the economically active age group (18–64) demonstrates more varied coverage across all three categories.</p>
<p>These insights highlight the need for policies that specifically address age-related disparities in insurance coverage. For instance, increasing outreach and enrollment efforts for children and their families or expanding public insurance programs for economically active adults could help reduce the number of uninsured individuals. By focusing on these trends, data-driven strategies to improve equitable access to health insurance across all demographics can be developed.</p>
</section>
<section id="part-ii-c-critical-engagement-with-chatgpt" class="level2">
<h2 class="anchored" data-anchor-id="part-ii-c-critical-engagement-with-chatgpt">Part II-C Critical Engagement with ChatGPT</h2>
<p>A key opportunity where I had the chance to employ Generative AI tools was during the visualization processes when developing my Choropleth visualisation in my RShiny App. While creating a function to plot the spatial distribution of health insurance packages across the US, I was able to employ ChatGPT, alongside my other module content, to learn how to work with visualising Shapefile data.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>server_gpt_assisted <span class="ot">&lt;-</span> <span class="cf">function</span>(input, output) {</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Render plot1 for Choropleth Map (Tab 1 - Visualisation Number 1)</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>  output<span class="sc">$</span>plot1 <span class="ot">&lt;-</span> <span class="fu">renderPlot</span>({</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>    selected_column <span class="ot">&lt;-</span> <span class="cf">switch</span>(input<span class="sc">$</span>insurancetype,</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>                              <span class="st">"Uninsured Rate (%)"</span> <span class="ot">=</span> <span class="st">"uninsured_rate"</span>,</span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>                              <span class="st">"Privately Insured (%)"</span> <span class="ot">=</span> <span class="st">"private_insurance_rate"</span>,</span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>                              <span class="st">"Publicly Insured (%)"</span> <span class="ot">=</span> <span class="st">"public_insurance_rate"</span>)</span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a>    <span class="fu">ggplot</span>(state_insurance) <span class="sc">+</span></span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a>      <span class="fu">geom_sf</span>(<span class="fu">aes</span>(<span class="at">fill =</span> <span class="fu">get</span>(selected_column)), <span class="at">color =</span> <span class="st">"white"</span>) <span class="sc">+</span> <span class="co"># using spatial data from US Census</span></span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a>      <span class="fu">scale_fill_viridis_c</span>(<span class="at">name =</span> input<span class="sc">$</span>insurancetype) <span class="sc">+</span> <span class="co"># Using Pre-Made R Colour Palettes</span></span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a>      <span class="fu">coord_sf</span>(</span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a>        <span class="at">xlim =</span> <span class="fu">c</span>(<span class="sc">-</span><span class="dv">125</span>, <span class="sc">-</span><span class="dv">66</span>),  <span class="co"># Longitude limits for the continental US </span></span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a>        <span class="at">ylim =</span> <span class="fu">c</span>(<span class="dv">24</span>, <span class="dv">49</span>),     <span class="co"># Latitude limits for the continental US</span></span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true" tabindex="-1"></a>        <span class="at">expand =</span> <span class="cn">FALSE</span>         <span class="co"># Ensure Map is zoomed in on the US</span></span>
<span id="cb6-17"><a href="#cb6-17" aria-hidden="true" tabindex="-1"></a>      ) <span class="sc">+</span></span>
<span id="cb6-18"><a href="#cb6-18" aria-hidden="true" tabindex="-1"></a>      <span class="fu">theme_minimal</span>() <span class="sc">+</span></span>
<span id="cb6-19"><a href="#cb6-19" aria-hidden="true" tabindex="-1"></a>      <span class="fu">labs</span>(</span>
<span id="cb6-20"><a href="#cb6-20" aria-hidden="true" tabindex="-1"></a>        <span class="at">title =</span> <span class="fu">paste</span>(input<span class="sc">$</span>insurancetype, <span class="st">"in US States (2019)"</span>),</span>
<span id="cb6-21"><a href="#cb6-21" aria-hidden="true" tabindex="-1"></a>        <span class="at">caption =</span> <span class="st">"Source: ACS 2019, UK Census"</span></span>
<span id="cb6-22"><a href="#cb6-22" aria-hidden="true" tabindex="-1"></a>      )</span>
<span id="cb6-23"><a href="#cb6-23" aria-hidden="true" tabindex="-1"></a>  })</span>
<span id="cb6-24"><a href="#cb6-24" aria-hidden="true" tabindex="-1"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>As seen in the code chunk above, generative AI tools helped me to understand how to read shapefile data in a ShinyAPP and also scaling my data to only cover the US region. Having previously worked with shapefile data, but through a csv. format, this was a learning experience for me and I was able to build upon my existing knowledge.</p>
<p>Additionally, while writing this project on Quarto, I found GenAI tools helpful in proofreading text and identifying any small errors. As Quarto does not have any built-in editor, for example like that in Microsoft Word, GenAI was a useful proof-reading tool.</p>
<p>However, there are instances where ChatGPT was unable to provide insightful contributions. For instance, when exploring methods to visualise time data, ChatGPT provides suggestions where a much larger dataset is needed. However, the ACS is conducted every 5 years, making this recent and relevant data relatively sparse. This is something that GenAI tools cannot help us with as they do not know the context of the data the user is working with. Nonetheless, I found GenAI tools a helpful collaborative tool in refining this data analysis project.</p>
</section>
<section id="report-conclusions" class="level2">
<h2 class="anchored" data-anchor-id="report-conclusions">Report Conclusions</h2>
<p>This report highlights the utility of combining advanced data analysis techniques with innovative visualization methods to explore health insurance trends in the United States. By leveraging the 2019 American Community Survey (ACS) data and integrating tools like R Shiny, the project provides critical insights into spatial and demographic disparities in healthcare coverage.</p>
<p>The interactive dashboard serves as a valuable tool for policymakers and researchers, showcasing variations in insurance coverage by state, age group, and insurance type. Each visualization—whether the choropleth map, line chart, or stacked bar chart—offers a unique perspective on the challenges and progress within the U.S. healthcare system. These visual tools emphasize the disparities in coverage, guiding data-driven interventions to promote equitable access to healthcare. It underscores the potential of data visualization and AI-assisted tools in bridging knowledge gaps, fostering informed decision-making, and driving meaningful healthcare reforms. Such interactive platforms can provide a foundation for future research and initiatives aimed at reducing health insurance disparities across the United States.</p>
</section>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>